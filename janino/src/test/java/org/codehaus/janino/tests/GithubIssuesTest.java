
/*
 * Janino - An embedded Java[TM] compiler
 *
 * Copyright (c) 2017 Arno Unkrig. All rights reserved.
 * Copyright (c) 2015-2016 TIBCO Software Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
 * following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice, this list of conditions and the
 *       following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *       following disclaimer in the documentation and/or other materials provided with the distribution.
 *    3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote
 *       products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.codehaus.janino.tests;

import java.io.FileReader;
import java.io.IOException;
import java.io.StringReader;
import java.lang.reflect.InvocationTargetException;
import java.nio.charset.UnsupportedCharsetException;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.codehaus.commons.compiler.CompileException;
import org.codehaus.commons.compiler.IClassBodyEvaluator;
import org.codehaus.commons.compiler.IExpressionEvaluator;
import org.codehaus.commons.nullanalysis.Nullable;
import org.codehaus.janino.ClassBodyEvaluator;
import org.codehaus.janino.ClassLoaderIClassLoader;
import org.codehaus.janino.ExpressionEvaluator;
import org.codehaus.janino.IClassLoader;
import org.codehaus.janino.Java;
import org.codehaus.janino.Java.AbstractCompilationUnit;
import org.codehaus.janino.Java.CompilationUnit;
import org.codehaus.janino.Java.IntegerLiteral;
import org.codehaus.janino.Java.Rvalue;
import org.codehaus.janino.Parser;
import org.codehaus.janino.Scanner;
import org.codehaus.janino.ScriptEvaluator;
import org.codehaus.janino.SimpleCompiler;
import org.codehaus.janino.UnitCompiler;
import org.codehaus.janino.util.ClassFile;
import org.codehaus.janino.util.DeepCopier;
import org.junit.Assert;
import org.junit.Ignore;
import org.junit.Test;

/**
 * Tests that reproduce <a href="https://github.com/janino-compiler/janino/issues">the issues reported on GITHUB</a>.
 */
public
class GithubIssuesTest {

    /**
     * A "degenerated" {@link ExpressionEvaluator} that suppresses the loading of the generated bytecodes into a
     * class loader.
     * <p>
     *   {@link ScriptEvaluator}, {@link ClassBodyEvaluator} and {@link SimpleCompiler} should be adaptable in very
     *   much the same way.
     * </p>
     * <p>
     *   The methods of {@link IExpressionEvaluator} that are related to loaded classes must not be used, and all
     *   throw {@link RuntimeException}s. These methods are:
     * </p>
     * <ul>
     *   <li>{@link #createFastEvaluator(java.io.Reader, Class, String[])}</li>
     *   <li>{@link #createFastEvaluator(org.codehaus.janino.Scanner, Class, String[])}</li>
     *   <li>{@link #createFastEvaluator(String, Class, String[])}</li>
     *   <li>{@link #evaluate(Object[])}</li>
     *   <li>{@link #evaluate(int, Object[])}</li>
     *   <li>{@link #getClazz()}</li>
     *   <li>{@link #getMethod()}</li>
     *   <li>{@link #getMethod(int)}</li>
     * </ul>
     *
     * @see #getBytecodes()
     */
    public static
    class ExpressionCompiler extends ExpressionEvaluator {

        @Nullable private Map<String, byte[]> classes;

        /**
         * @return The bytecodes that were generated when {@link #cook(String)} was invoked
         */
        public Map<String, byte[]>
        getBytecodes() {

            Map<String, byte[]> result = this.classes;
            if (result == null) throw new IllegalStateException("Must only be called after \"cook()\"");

            return result;
        }

        // --------------------------------------------------------------------

        // Override this method to prevent the loading of the class files into a ClassLoader.
        @Override public void
        cook(Map<String, byte[]> classes) {

            // Instead of loading the bytecodes into a ClassLoader, store the bytecodes in "this.classes".
            this.classes = classes;
        }

        // Override this method to prevent the retrieval of the generated java.lang.Classes.
        @Override protected void
        cook2(CompilationUnit compilationUnit) throws CompileException {
            this.cook(compilationUnit);
        }
    }

    /**
     * @see <a href="https://github.com/janino-compiler/janino/issues/19">GITHUB issue #19: Get bytecode after
     *      compile</a>
     */
    @Test public void
    testCompileToBytecode() throws CompileException {

        // Set up an ExpressionCompiler and cook the expression.
        ExpressionCompiler ec = new ExpressionCompiler();
        ec.setExpressionType(int.class);

        ec.cook("7");

        // Retrieve the generated bytecode from the ExpressionCompiler. The result is a map from class name
        // to the class's bytecode.
        Map<String, byte[]> result = ec.getBytecodes();
        Assert.assertNotNull(result);

        // verify that exactly _one_ class was generated.
        Assert.assertEquals(1, result.size());

        // Verify the class's name.
        byte[] ba = result.get(IClassBodyEvaluator.DEFAULT_CLASS_NAME);
        Assert.assertNotNull(ba);

        // Verify that the generated bytecode looks "reasonable", i.e. starts with the charcteristic
        // "magic bytes" and has an approximate size.
        Assert.assertArrayEquals(
            new byte[] { (byte) 0xca, (byte) 0xfe, (byte) 0xba, (byte) 0xbe },
            Arrays.copyOf(ba, 4)
        );
        Assert.assertTrue(Integer.toString(ba.length), ba.length > 150);
        Assert.assertTrue(Integer.toString(ba.length), ba.length < 300);
    }

    @Test public void
    testExpressionCompilerMethods() throws CompileException, IOException, InvocationTargetException {

        Class<?> interfaceToImplement = Comparable.class;
        String[] parameterNames       = { "o" };
        String   e                    = "7";
        Object[] arguments            = { "" };

        CASES: for (int i = 0;; i++) {

            ExpressionCompiler ec = new ExpressionCompiler();
            ec.setExpressionType(int.class);

            if (i >= 3 && i <= 7) ec.cook(e);

            try {
                switch (i) {

                // All these invocations are expected to throw an IllegalStateException.
                // SUPPRESS CHECKSTYLE LineLength:8
                case 0: ec.createFastEvaluator(new StringReader(e), interfaceToImplement, parameterNames);                    break;
                case 1: ec.createFastEvaluator(new Scanner(null, new StringReader(e)), interfaceToImplement, parameterNames); break;
                case 2: ec.createFastEvaluator(e, interfaceToImplement, parameterNames);                                      break;
                case 3: ec.evaluate(arguments);                                                                               break;
                case 4: ec.evaluate(0, arguments);                                                                            break;
                case 5: ec.getClazz();                                                                                        break;
                case 6: ec.getMethod();                                                                                       break;
                case 7: ec.getMethod(0);                                                                                      break;

                case 8: break CASES;

                default: continue;
                }
                Assert.fail("Exception expected (case " + i + ")");
            } catch (IllegalStateException ise) {
                ;
            }
        }
    }

    @Test public void
    testIssue91() throws Exception {

        // Parse the framework code.
        CompilationUnit cu = (CompilationUnit) new Parser(new Scanner(
            "user expression", // This will appear in stack traces as "file name".
            new StringReader(
                ""
                + "package com.acme.framework;\n"
                + "\n"
                + "public\n"
                + "class Framework {\n"
                + "\n"
                + "    public static void\n"
                + "    frameworkMethod() {\n"
                + "        System.out.println(\"frameworkMethod()\");\n"
                + "    }\n"
                + "\n"
                + "    public static void\n"
                + "    userMethod() {\n"
                + "        System.out.println(77);\n" // <= "77" will be replaced with the user expression!
                + "    }\n"
                + "}\n"
            )
        )).parseAbstractCompilationUnit();

        // Parse the "user expression".
        final Rvalue userExpression = (
            new Parser(new Scanner(
                null,
                new StringReader( // Line numbers will appear in stack traces.
                    ""
                    + "\n"
                    + "\n"
                    + "java.nio.charset.Charset.forName(\"kkk\")\n" // <= Causes an UnsupportedCharsetException
                )
            ))
            .parseExpression()
            .toRvalueOrCompileException()
        );

        // Merge the framework code with the user expression.
        cu = new DeepCopier() {

            @Override public Rvalue
            copyIntegerLiteral(IntegerLiteral subject) throws CompileException {
                if ("77".equals(subject.value)) return userExpression;
                return super.copyIntegerLiteral(subject);
            }
        }.copyCompilationUnit(cu);

        // Compile the code into a ClassLoader.
        SimpleCompiler sc = new SimpleCompiler();
        sc.setDebuggingInformation(true, true, true);
        sc.cook(cu);
        ClassLoader cl = sc.getClassLoader();

        // Find the generated class by name.
        Class<?> c = cl.loadClass("com.acme.framework.Framework");

        // Invoke the class's methods.
        c.getMethod("frameworkMethod").invoke(null);
        try {
            c.getMethod("userMethod").invoke(null);
            Assert.fail("InvocationTargetException expected");
        } catch (InvocationTargetException ite) {
            Throwable te = ite.getTargetException();
            Assert.assertEquals(UnsupportedCharsetException.class, te.getClass());
            StackTraceElement top = te.getStackTrace()[1];
            Assert.assertEquals("userMethod", top.getMethodName());
            Assert.assertEquals("user expression", top.getFileName());
            Assert.assertEquals(3, top.getLineNumber());
        }
    }

    // This is currently failing
    // https://github.com/codehaus/janino/issues/4
    @Ignore
    @Test public void
    testReferenceQualifiedSuper() throws Exception {
        GithubIssuesTest.doCompile(true, true, false, GithubIssuesTest.RESOURCE_DIR + "/a/Test.java");
    }
    private static final String RESOURCE_DIR = "../commons-compiler-tests/src/test/resources";

    public static List<ClassFile>
    doCompile(
        boolean   debugSource,
        boolean   debugLines,
        boolean   debugVars,
        String... fileNames
    ) throws Exception {

        // Parse each compilation unit.
        final List<AbstractCompilationUnit> acus = new LinkedList<AbstractCompilationUnit>();
        final IClassLoader                  cl   = new ClassLoaderIClassLoader(GithubIssuesTest.class.getClassLoader());
        List<ClassFile>                     cfs  = new LinkedList<ClassFile>();
        for (String fileName : fileNames) {

            FileReader r = new FileReader(fileName);
            try {
                Java.AbstractCompilationUnit acu = new Parser(new Scanner(fileName, r)).parseAbstractCompilationUnit();
                acus.add(acu);

                // Compile them.
                cfs.addAll(Arrays.asList(new UnitCompiler(acu, cl).compileUnit(debugSource, debugLines, debugVars)));
            } finally {
                try { r.close(); } catch (Exception e) {}
            }
        }
        return cfs;
    }

}
